{
  "questions": [
    {
      "id": "1",
      "category": "Основы Dart",
      "question": "В чем разница между 'final' и 'const' в Dart?",
      "answer": "'final' - значение устанавливается в RUNTIME и не меняется. 'const' - значение известно в COMPILE-TIME и является константой.\n\nПримеры:\nfinal time = DateTime.now(); // OK - runtime значение\nconst pi = 3.14; // OK - compile-time значение\nconst time = DateTime.now(); // ERROR! - нельзя использовать runtime значение",
      "hint": "final = runtime, const = compile-time"
    },
    {
      "id": "2",
      "category": "Основы Dart",
      "question": "Что такое Null Safety в Dart?",
      "answer": "Null Safety - система типов, предотвращающая ошибки null reference. Все типы по умолчанию non-nullable. Для nullable типа добавляется '?'. Используются null-aware операторы (??, ?., !).\n\nПример:\nString name = 'John'; // non-nullable\nString? nullableName = null; // nullable\nint length = nullableName?.length ?? 0; // безопасный доступ",
      "hint": "Типы non-nullable по умолчанию, ? для nullable"
    },
    {
      "id": "3",
      "category": "Основы Dart",
      "question": "Какие коллекции есть в Dart?",
      "answer": "1. List - упорядоченная коллекция с индексами (важен порядок)\n2. Set - неупорядоченная коллекция уникальных элементов (важна уникальность)\n3. Map - коллекция пар ключ-значение (ассоциативный массив)\n\nВсе могут быть фиксированной длины или growable.",
      "hint": "List - порядок, Set - уникальность, Map - ключ-значение"
    },
    {
      "id": "4",
      "category": "Основы Flutter",
      "question": "В чем разница между StatelessWidget и StatefulWidget?",
      "answer": "StatelessWidget - неизменяемый виджет без внутреннего состояния. StatefulWidget - виджет с изменяемым состоянием, использует setState() для обновления UI.\n\nStatelessWidget: только build() метод, легковесный.\nStatefulWidget: имеет объект State, может менять состояние.",
      "hint": "Stateless - без состояния, Stateful - с состоянием"
    },
    {
      "id": "5",
      "category": "Основы Flutter",
      "question": "Расскажите про жизненный цикл StatefulWidget",
      "answer": "1. createState() - создание State\n2. initState() - инициализация (1 раз)\n3. didChangeDependencies() - при изменении InheritedWidget\n4. build() - построение UI (много раз)\n5. didUpdateWidget() - при обновлении виджета\n6. setState() - триггер перерисовки\n7. deactivate() - удаление из дерева\n8. dispose() - окончательное удаление, очистка",
      "hint": "initState → build → [много раз build] → dispose"
    },
    {
      "id": "6",
      "category": "State Management",
      "question": "Когда использовать Provider, а когда BloC/Cubit?",
      "answer": "Provider - для простого состояния и dependency injection (тема, настройки).\n\nBloc/Cubit - для сложной бизнес-логики, когда нужны события, тестирование, отслеживание состояния (аутентификация, корзина).\n\nCubit - упрощенный BloC без событий.",
      "hint": "Provider - простое, BloC - сложная логика"
    },
    {
      "id": "7",
      "category": "State Management",
      "question": "Что такое Riverpod и чем он лучше Provider?",
      "answer": "Riverpod - современная замена Provider. Преимущества:\n1. Compile-safe (ошибки на этапе компиляции)\n2. Не зависит от BuildContext\n3. Легкое тестирование\n4. Несколько провайдеров одного типа\n5. Автоматическое кэширование\n6. Лучшая производительность\n\nНедостаток: крутая кривая обучения.",
      "hint": "Riverpod = Provider 2.0, compile-safe, не зависит от context"
    },
    {
      "id": "8",
      "category": "Асинхронность",
      "question": "Разница между Future и Stream?",
      "answer": "Future - возвращает одно значение в будущем (запрос к API, чтение файла).\n\nStream - возвращает последовательность значений во времени (websocket, геолокация, user events).\n\nasync/await - для работы с Future в синхронном стиле.",
      "hint": "Future - одно значение, Stream - много значений"
    },
    {
      "id": "9",
      "category": "Асинхронность",
      "question": "Что такое Isolate и когда его использовать?",
      "answer": "Isolate - отдельный поток выполнения со своей памятью. Общение только через сообщения.\n\nИспользовать для:\n1. Тяжелых вычислений (обработка изображений)\n2. Сложных математических расчетов\n3. Операций, блокирующих UI (>16мс)\n4. Фоновых задач\n\nНе использовать для простых async операций.",
      "hint": "Isolate = отдельный поток, общение через сообщения"
    },
    {
      "id": "10",
      "category": "Навигация",
      "question": "Как работает навигация в Flutter?",
      "answer": "Навигация работает через стек (LIFO) с помощью Navigator:\n1. Navigator управляет стеком маршрутов\n2. push() - добавляет маршрут\n3. pop() - удаляет маршрут\n4. pushReplacement() - заменяет маршрут\n\nПодходы:\n- Именованные маршруты (через MaterialApp.routes)\n- Анонимные маршруты (через Navigator.push)",
      "hint": "Navigator управляет стеком маршрутов, push/pop для навигации"
    },
    {
      "id": "11",
      "category": "Производительность",
      "question": "Как оптимизировать производительность Flutter приложения?",
      "answer": "1. Используйте const везде где возможно\n2. ListView.builder вместо Column с детьми\n3. Кэширование изображений (cached_network_image)\n4. Оптимизация build() методов\n5. Профилирование с DevTools\n6. Избегайте setState() в больших деревьях\n7. Используйте RepaintBoundary\n8. Используйте Keys для списков\n9. Оптимизация анимаций\n10. Используйте Isolates для тяжелых вычислений",
      "hint": "const, ListView.builder, DevTools для профилирования"
    },
    {
      "id": "12",
      "category": "API и сеть",
      "question": "Разница между GET и POST запросами?",
      "answer": "GET - получение данных с сервера. Параметры в URL, кэшируется, не должен менять состояние сервера.\n\nPOST - отправка данных на сервер для создания/обновления. Данные в теле запроса, не кэшируется, нет ограничений по объему.",
      "hint": "GET - получение, POST - отправка данных"
    },
    {
      "id": "13",
      "category": "API и сеть",
      "question": "Что такое REST API?",
      "answer": "REST API - архитектурный стиль, где сущности представлены как ресурсы (URL).\n\nОсновные методы HTTP:\n- GET - получение\n- POST - создание\n- PUT/PATCH - обновление\n- DELETE - удаление\n- HEAD, OPTIONS - служебные",
      "hint": "REST - ресурсы как URL, CRUD операции через HTTP"
    },
    {
      "id": "14",
      "category": "Базы данных",
      "question": "Почему выбрать Isar, а не Hive или SQLite?",
      "answer": "Isar:\n- Нативная производительность (написана на C++)\n- Встроенные индексы\n- Богатые типы запросов\n- Интеграция с Flutter DevTools\n\nHive - очень быстрый, но менее удобная работа с отношениями.\nSQLite - проверенное решение, но больше boilerplate кода.",
      "hint": "Isar - нативная производительность, индексы, DevTools интеграция"
    },
    {
      "id": "15",
      "category": "Архитектура",
      "question": "Объясните принципы SOLID",
      "answer": "SOLID - принципы объектно-ориентированного проектирования:\n1. S - Single Responsibility (одна ответственность)\n2. O - Open/Closed (открыт для расширения, закрыт для модификации)\n3. L - Liskov Substitution (наследники заменяют родителей)\n4. I - Interface Segregation (много специализированных интерфейсов)\n5. D - Dependency Inversion (зависимости от абстракций)",
      "hint": "S - одна ответственность, O - открыт/закрыт, L - подстановка, I - разделение, D - инверсия"
    },
    {
      "id": "16",
      "category": "ООП в Dart",
      "question": "Какие принципы ООП поддерживает Dart?",
      "answer": "Dart поддерживает все 4 принципа ООП:\n1. Инкапсуляция - private поля через _\n2. Наследование - extends (одиночное наследование)\n3. Полиморфизм - переопределение методов\n4. Абстракция - абстрактные классы, интерфейсы",
      "hint": "Инкапсуляция, наследование, полиморфизм, абстракция"
    },
    {
      "id": "17",
      "category": "Инструменты",
      "question": "Что такое Garbage Collector в Dart?",
      "answer": "Dart использует продвинутый Garbage Collector:\n- Generational Garbage Collection (young/old space)\n- Concurrent mark-sweep (не останавливает программу)\n- Incremental compaction (уменьшает фрагментацию)\n- Работает автоматически\n\nМожно вызвать System.gc(), но не рекомендуется.",
      "hint": "Dart GC: Generational, Concurrent mark-sweep, автоматический"
    },
    {
      "id": "18",
      "category": "Виджеты",
      "question": "Что такое Key и зачем он нужен?",
      "answer": "Key помогает Flutter идентифицировать виджеты при обновлении.\n\nТипы Keys:\n- LocalKey (ValueKey, ObjectKey) - для списков\n- GlobalKey - для уникальной идентификации (доступ к FormState)\n\nБез ключей Flutter может перепутать виджеты при обновлении.",
      "hint": "Key помогает идентифицировать виджеты, особенно в списках"
    },
    {
      "id": "19",
      "category": "Пакеты",
      "question": "Что такое Dio и зачем он нужен?",
      "answer": "Dio - HTTP клиент для Dart/Flutter. Преимущества перед стандартным http:\n- Interceptors (перехватчики)\n- Cancellation (отмена запросов)\n- Form data поддержка\n- Лучшая обработка ошибок\n- Timeout настройка\n- Логирование запросов",
      "hint": "Dio - улучшенный HTTP клиент с interceptors, cancellation"
    },
    {
      "id": "20",
      "category": "Тестирование",
      "question": "Какие виды тестов есть в Flutter?",
      "answer": "1. Unit тесты - тестирование отдельных функций/классов\n2. Widget тесты - тестирование виджетов в изоляции\n3. Integration тесты - тестирование всего приложения\n\nИспользуются пакеты:\n- test - для unit тестов\n- flutter_test - для widget тестов\n- integration_test - для интеграционных тестов",
      "hint": "Unit тесты, Widget тесты, Integration тесты"
    },
    {
      "id": "21",
      "category": "Основы Dart",
      "question": "Что такое Mixin и когда его использовать?",
      "answer": "Mixin - это способ повторного использования кода в нескольких иерархиях классов без использования наследования.\n\nКлючевые особенности:\n1. Миксины не могут быть инстанциированы\n2. Предоставляют методы и свойства классам, которые их используют\n3. Можно использовать несколько миксинов в одном классе\n4. Решают проблему множественного наследования\n\nСинтаксис:\n// Объявление миксина\nmixin LoggingMixin {\n  void log(String message) {\n    print('Log: \$message');\n  }\n}\n\n// Использование в классе\nclass UserRepository with LoggingMixin, ValidationMixin {\n  void saveUser() {\n    log('Saving user...'); // Метод из миксина\n  }\n}\n\nКогда использовать:\n1. Для добавления общей функциональности разным классам\n2. Когда нужно избежать дублирования кода\n3. Для реализации интерфейсов с частичной реализацией\n4. Для добавления utility-методов\n\nОграничения:\n- Миксины не могут иметь конструкторов\n- Можно использовать ключевое слово 'on' для ограничения использования\n\nПример с 'on':\nmixin RepositoryMixin on DatabaseService {\n  // Этот миксин можно использовать только в классах,\n  // которые наследуют или используют DatabaseService\n}",
      "hint": "Mixin для повторного использования кода, альтернатива множественному наследованию"
    },
    {
      "id": "22",
      "category": "Основы Dart",
      "question": "Объясните разницу между async/await и Future.then()",
      "answer": "Оба подхода работают с асинхронными операциями, но имеют разные стили и применения.\n\n1. async/await (синтаронный стиль):\n- Позволяет писать асинхронный код, который выглядит как синхронный\n- Более читаемый, особенно при цепочках операций\n- Легче обрабатывать ошибки с try/catch\n\nПример async/await:\nFuture<void> fetchUserData() async {\n  try {\n    final user = await fetchUser();\n    final profile = await fetchProfile(user.id);\n    final settings = await fetchSettings(profile.id);\n    print('All data fetched');\n  } catch (e) {\n    print('Error: \$e');\n  }\n}\n\n2. Future.then() (callback стиль):\n- Более функциональный стиль\n- Полезен для простых цепочек\n- Может быть более производительным в некоторых случаях\n\nПример Future.then():\nvoid fetchUserData() {\n  fetchUser()\n    .then((user) => fetchProfile(user.id))\n    .then((profile) => fetchSettings(profile.id))\n    .then((_) => print('All data fetched'))\n    .catchError((e) => print('Error: \$e'));\n}\n\nКлючевые отличия:\n- async/await создает состояние в функции (можно использовать локальные переменные)\n- Future.then() цепочки могут быть сложнее для чтения при множестве операций\n- В async функциях можно использовать await for для работы со Stream\n- async функции всегда возвращают Future\n\nРекомендации:\n- Используйте async/await для сложной логики\n- Используйте Future.then() для простых преобразований\n- Не смешивайте оба стиля без необходимости",
      "hint": "async/await для читаемости, Future.then() для простых цепочек"
    },
    {
      "id": "23",
      "category": "Flutter Architecture",
      "question": "Что такое Clean Architecture и как ее применять в Flutter?",
      "answer": "Clean Architecture (Чистая Архитектура) - архитектурный подход, предложенный Робертом Мартином, который разделяет приложение на слои с четкими зависимостями.\n\nСлои в Clean Architecture:\n1. Domain Layer (Ядро):\n   - Entities (бизнес-сущности)\n   - Use Cases (бизнес-правила)\n   - Repository Interfaces\n   - Не зависит от внешних фреймворков\n\n2. Data Layer:\n   - Repository Implementations\n   - Data Sources (API, Local DB)\n   - DTOs (Data Transfer Objects)\n   - Зависит от Domain Layer\n\n3. Presentation Layer:\n   - UI Components (Widgets)\n   - State Management (Bloc, Provider)\n   - ViewModels/Presenters\n   - Зависит от Domain Layer\n\nПреимущества:\n- Тестируемость (можно тестировать слои изолированно)\n- Поддерживаемость (четкое разделение ответственности)\n- Гибкость (легко менять реализации)\n- Независимость от фреймворков\n\nПример структуры проекта Flutter:\nlib/\n  data/\n    datasources/      # API, Local DB\n    models/          # DTOs\n    repositories/    # Реализации репозиториев\n  domain/\n    entities/        # Бизнес-сущности\n    repositories/    # Интерфейсы репозиториев\n    usecases/        # Бизнес-логика\n  presentation/\n    bloc/           # State Management\n    pages/          # Страницы\n    widgets/        # Переиспользуемые виджеты\n    providers/      # Провайдеры\n\nDependency Injection:\n- Используйте get_it или provider для DI\n- Инжектируйте зависимости через конструкторы",
      "hint": "3 слоя: Domain → Data → Presentation, Dependency Inversion Principle"
    },
    {
      "id": "24",
      "category": "State Management",
      "question": "Что такое GetX и в чем его преимущества/недостатки?",
      "answer": "GetX - это легковесный, но мощный пакет для Flutter, который предоставляет:\n1. State Management\n2. Route Management\n3. Dependency Injection\n4. Utilities (Snackbars, Dialogs, etc.)\n\nПреимущества GetX:\n1. Минимальный boilerplate код\n2. Высокая производительность (реактивность без StatefulWidget)\n3. Встроенная навигация с поддержкой middlewares\n4. Встроенный DI контейнер\n5. Международная комьюнити и документация\n6. Нет необходимости в BuildContext\n7. Простота обучения\n\nНедостатки GetX:\n1. Меньше контроля над жизненным циклом\n2. Может привести к нарушениям принципов чистой архитектуры\n3. Меньше инструментов для крупных enterprise приложений\n4. Критика за \"магию\" (неявные зависимости)\n\nПример использования:\n// State Management\nclass CounterController extends GetxController {\n  var count = 0.obs; // .obs делает переменную реактивной\n  \n  void increment() {\n    count++;\n  }\n}\n\n// В виджете\nclass CounterPage extends StatelessWidget {\n  final controller = Get.put(CounterController());\n  \n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Obx(() => Text('Count: \${controller.count}')),\n      floatingActionButton: FloatingActionButton(\n        onPressed: controller.increment,\n      ),\n    );\n  }\n}\n\n// Навигация\nGet.to(NextPage()); // Переход\nGet.back(); // Назад\nGet.offAll(HomePage()); // Очистка стека\n\nКогда использовать GetX:\n- Для быстрого прототипирования\n- Для небольших и средних приложений\n- Когда нужно минимум кода\n- Для разработчиков, переходящих с других фреймворков\n\nКогда не использовать GetX:\n- Крупные enterprise приложения\n- Когда важна строгая архитектура\n- Команды, уже использующие другие решения (Bloc, Provider)",
      "hint": "GetX: всё в одном, минимальный boilerplate, но может нарушать чистую архитектуру"
    },
    {
      "id": "25",
      "category": "Производительность",
      "question": "Как работать с большими списками в Flutter?",
      "answer": "Для работы с большими списками необходимо использовать специальные техники оптимизации:\n\n1. ListView.builder / ListView.separated:\n   - Создает элементы лениво (on-demand)\n   - Не создает все элементы сразу\n   - Пример:\n     ListView.builder(\n       itemCount: 10000,\n       itemBuilder: (context, index) {\n         return ListTile(title: Text('Item \$index'));\n       },\n     )\n\n2. GridView.builder - аналогично для сеток\n\n3. Sliver семейство виджетов для CustomScrollView:\n   - SliverList\n   - SliverGrid\n   - SliverAppBar\n   - SliverToBoxAdapter\n\n4. Пейджинг (Pagination):\n   - Загружать данные порциями\n   - Использовать scroll controllers для определения конца списка\n   - Пакеты: flutter_infinite_scroll, paging\n\n5. Кэширование изображений:\n   - cached_network_image для сетевых изображений\n   - Ограничение размера изображений\n   - Использование placeholders\n\n6. Оптимизация itemBuilder:\n   - Использовать const конструкторы\n   - Кэшировать дорогие вычисления\n   - Избегать создания объектов в build методах\n\n7. Keys для списков:\n   - ValueKey для элементов с уникальными идентификаторами\n   - Помогает Flutter эффективно обновлять список\n\n8. Сохранение состояния элементов:\n   - AutomaticKeepAliveClientMixin\n   - Сохраняет состояние прокрутки\n\n9. Виртуализация:\n   - flutter_virtualized_view (для очень больших списков)\n\n10. Профилирование:\n    - DevTools Performance tab\n    - TrackWidgetRebuilds\n    - DebugPaint\n\nПример с пейджингом:\nclass PaginatedList extends StatefulWidget {\n  @override\n  _PaginatedListState createState() => _PaginatedListState();\n}\n\nclass _PaginatedListState extends State<PaginatedList> {\n  final ScrollController _controller = ScrollController();\n  final List<Item> _items = [];\n  bool _isLoading = false;\n  int _page = 0;\n\n  @override\n  void initState() {\n    super.initState();\n    _loadMore();\n    _controller.addListener(() {\n      if (_controller.position.pixels == _controller.position.maxScrollExtent) {\n        _loadMore();\n      }\n    });\n  }\n\n  Future<void> _loadMore() async {\n    if (_isLoading) return;\n    setState(() => _isLoading = true);\n    \n    final newItems = await fetchItems(page: _page++);\n    setState(() {\n      _items.addAll(newItems);\n      _isLoading = false;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return ListView.builder(\n      controller: _controller,\n      itemCount: _items.length + 1,\n      itemBuilder: (context, index) {\n        if (index == _items.length) {\n          return _isLoading \n              ? Center(child: CircularProgressIndicator())\n              : SizedBox.shrink();\n        }\n        return ListTile(\n          key: ValueKey(_items[index].id),\n          title: Text(_items[index].title),\n        );\n      },\n    );\n  }\n}",
      "hint": "ListView.builder, пейджинг, кэширование, Keys, профилирование"
    },
    {
      "id": "26",
      "category": "Animations",
      "question": "Какие типы анимаций есть в Flutter и когда их использовать?",
      "answer": "Flutter предоставляет богатую систему анимаций, которую можно разделить на несколько категорий:\n\n1. Implicit Animations (Неявные анимации):\n   - Простые в использовании\n   - Автоматически анимируют изменения свойств\n   - Виджеты: AnimatedContainer, AnimatedOpacity, AnimatedPadding\n   - Пример:\n     AnimatedContainer(\n       duration: Duration(seconds: 1),\n       width: _expanded ? 200 : 100,\n       height: _expanded ? 200 : 100,\n       color: _expanded ? Colors.red : Colors.blue,\n     )\n\n2. Explicit Animations (Явные анимации):\n   - Полный контроль над анимацией\n   - Используют AnimationController\n   - Виджеты: AnimationBuilder, Transition widgets\n   - Пример:\n     AnimationController(\n       duration: Duration(seconds: 2),\n       vsync: this,\n     );\n     \n     Animation<double> animation = CurvedAnimation(\n       parent: controller,\n       curve: Curves.easeIn,\n     );\n\n3. Physics-based Animations:\n   - Анимации, основанные на физике\n   - SpringSimulation, GravitySimulation\n   - Пакет: flutter/physics.dart\n\n4. Hero Animations:\n   - Переходы между экранами\n   - Общий элемент на двух экранах\n   - Пример:\n     // Screen 1\n     Hero(\n       tag: 'image-hero',\n       child: Image.network(imageUrl),\n     )\n     \n     // Screen 2\n     Hero(\n       tag: 'image-hero',\n       child: Image.network(imageUrl),\n     )\n\n5. Staggered Animations:\n   - Последовательные анимации\n   - Интервалы между анимациями\n   - Используют Interval в CurvedAnimation\n\n6. Custom Painter Animations:\n   - Рисование кастомной графики\n   - Используют CustomPaint и Canvas\n   - Анимация через repaint\n\nРекомендации по выбору:\n- Implicit: для простых анимаций свойств виджетов\n- Explicit: для сложных, синхронизированных анимаций\n- Hero: для переходов между экранами\n- Physics-based: для реалистичного движения\n- Custom Painter: для кастомной графики\n\nПроизводительность:\n- Используйте const конструкторы\n- Избегайте setState во время анимации\n- Используйте RepaintBoundary\n- Профилируйте с DevTools Performance\n\nПакеты для анимаций:\n- animations (Material Motion)\n- flutter_sequence_animation\n- flare_flutter (2D векторные анимации)\n- rive (интерактивные анимации)",
      "hint": "Implicit для простого, Explicit для контроля, Hero для переходов, CustomPainter для графики"
    },
    {
      "id": "27",
      "category": "Testing",
      "question": "Как тестировать State Management (Bloc, Provider, GetX)?",
      "answer": "Тестирование State Management - критически важная часть разработки Flutter приложений.\n\nОбщие принципы:\n1. Unit тесты для бизнес-логики\n2. Widget тесты для UI компонентов\n3. Mock зависимости\n4. Тестирование состояний и переходов\n\nТестирование BLoC:\n// BLoC тест\nvoid main() {\n  group('CounterBloc', () {\n    late CounterBloc bloc;\n\n    setUp(() {\n      bloc = CounterBloc();\n    });\n\n    tearDown(() {\n      bloc.close();\n    });\n\n    test('initial state is 0', () {\n      expect(bloc.state, equals(0));\n    });\n\n    test('increment increases state by 1', () {\n      // Ожидаемая последовательность состояний\n      expectLater(\n        bloc.stream,\n        emitsInOrder([0, 1]),\n      );\n\n      bloc.add(IncrementEvent());\n    });\n  });\n}\n\nТестирование Provider:\n// Provider тест\nvoid main() {\n  testWidgets('Counter increments', (WidgetTester tester) async {\n    await tester.pumpWidget(\n      ChangeNotifierProvider(\n        create: (_) => CounterModel(),\n        child: MyApp(),\n      ),\n    );\n\n    // Найти кнопку и нажать\n    await tester.tap(find.byIcon(Icons.add));\n    await tester.pump();\n\n    // Проверить обновление\n    expect(find.text('1'), findsOneWidget);\n  });\n}\n\nТестирование GetX:\n// GetX тест\nvoid main() {\n  test('CounterController increments', () async {\n    // Создать контроллер\n    final controller = CounterController();\n    \n    // Начать слушать изменения\n    final values = <int>[];\n    controller.count.listen(values.add);\n    \n    // Вызвать метод\n    controller.increment();\n    \n    // Проверить\n    expect(values, [0, 1]);\n    \n    // Очистка\n    Get.delete<CounterController>();\n  });\n}\n\nMocking зависимостей:\n// Создание mock\nclass MockUserRepository extends Mock implements UserRepository {}\n\n// Использование в тесте\nvoid main() {\n  late MockUserRepository mockRepository;\n  late UserBloc bloc;\n\n  setUp(() {\n    mockRepository = MockUserRepository();\n    bloc = UserBloc(repository: mockRepository);\n  });\n\n  test('fetches users', () async {\n    // Настроить mock\n    when(mockRepository.getUsers())\n        .thenAnswer((_) async => [User(id: 1, name: 'John')]);\n\n    // Ожидаемые состояния\n    expectLater(\n      bloc.stream,\n      emitsInOrder([\n        UserLoading(),\n        UserLoaded([User(id: 1, name: 'John')]),\n      ]),\n    );\n\n    // Запустить событие\n    bloc.add(FetchUsers());\n  });\n}\n\nИнтеграционное тестирование:\n// integration_test/app_test.dart\nvoid main() {\n  IntegrationTestWidgetsFlutterBinding.ensureInitialized();\n\n  testWidgets('Complete user flow', (WidgetTester tester) async {\n    // Запуск приложения\n    await tester.pumpWidget(MyApp());\n    \n    // Навигация\n    await tester.tap(find.text('Login'));\n    await tester.pumpAndSettle();\n    \n    // Ввод данных\n    await tester.enterText(find.byType(TextField), 'user@example.com');\n    await tester.tap(find.text('Submit'));\n    await tester.pumpAndSettle();\n    \n    // Проверка результата\n    expect(find.text('Welcome'), findsOneWidget);\n  });\n}\n\nЛучшие практики:\n1. Тестируйте все возможные состояния\n2. Тестируйте edge cases\n3. Используйте golden tests для UI\n4. Автоматизируйте тестирование в CI/CD\n5. Следите за coverage (минимум 70-80%)",
      "hint": "Unit тесты для логики, Widget тесты для UI, Mock зависимостей, Integration для полного потока"
    },
    {
      "id": "28",
      "category": "Performance",
      "question": "Как отлаживать и профилировать производительность Flutter приложения?",
      "answer": "Профилирование производительности - ключевой навык для разработки оптимизированных Flutter приложений.\n\nИнструменты:\n1. Flutter DevTools (основной инструмент):\n   - Performance tab: FPS, GPU, UI thread\n   - CPU Profiler: горячие методы\n   - Memory tab: утечки памяти\n   - Network tab: запросы\n   - Inspector: дерево виджетов\n\n2. Команды Flutter:\n   - flutter run --profile (для профилирования)\n   - flutter run --release (production build)\n   - flutter analyze (статический анализ)\n   - flutter test --coverage (покрытие тестами)\n\n3. Встроенные виджеты для отладки:\n   - DebugPaint (визуализация layout)\n   - debugDumpApp() (лог дерева виджетов)\n   - debugDumpRenderTree() (лог render tree)\n   - WidgetsBinding.instance.addTimingsCallback() (FPS)\n\nПошаговое профилирование:\n\nШаг 1: Измерение FPS\n- Откройте DevTools → Performance\n- Нажмите Record\n- Взаимодействуйте с приложением\n- Анализируйте frames (цель: 60 FPS, минимум 30 FPS)\n\nШаг 2: Анализ CPU\n- DevTools → CPU Profiler\n- Record выполнения\n- Ищите hot methods (методы, занимающие много времени)\n- Обратите внимание на build методы\n\nШаг 3: Анализ памяти:\n- DevTools → Memory\n- Сделайте snapshot памяти\n- Ищите утечки (объекты, которые не удаляются)\n- Проверьте размер images\n\nШаг 4: Анализ сети:\n- DevTools → Network\n- Оптимизируйте запросы\n- Используйте кэширование\n- Сжимайте изображения\n\nРаспространенные проблемы и решения:\n\n1. Jank (проседание FPS):\n   Проблема: Медленные build методы\n   Решение:\n   - Используйте const конструкторы\n   - Разделяйте большие виджеты\n   - Используйте RepaintBoundary\n\n2. Утечки памяти:\n   Проблема: Объекты не удаляются GC\n   Решение:\n   - Правильно используйте dispose()\n   - Избегайте циклических ссылок\n   - Используйте WeakReference\n\n3. Медленная загрузка:\n   Проблема: Долгий startup time\n   Решение:\n   - Ленивая загрузка ресурсов\n   - Используйте splash screen\n   - Оптимизируйте инициализацию\n\n4. Большой размер приложения:\n   Проблема: APK/IPA слишком большой\n   Решение:\n   - Используйте --split-debug-info\n   - Удалите неиспользуемые ресурсы\n   - Используйте dynamic delivery\n\nВиджеты для мониторинга:\nclass PerformanceOverlay extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Stack(\n      children: [\n        YourApp(),\n        Positioned(\n          top: 0,\n          child: PerformanceOverlay.allEnabled(),\n        ),\n      ],\n    );\n  }\n}\n\nПакеты для профилирования:\n- flutter_performance_toolbox\n- sentry_flutter (отслеживание ошибок)\n- firebase_performance (производительность в production)\n\nЛучшие практики:\n1. Профилируйте регулярно, не только при проблемах\n2. Тестируйте на реальных устройствах\n3. Используйте разные сценарии использования\n4. Сравнивайте производительность между версиями\n5. Документируйте оптимизации",
      "hint": "DevTools для анализа, --profile режим, const конструкторы, избегайте setState в анимациях"
    },
    {
      "id": "29",
      "category": "Platform Channels",
      "question": "Что такое Platform Channels и как работать с нативным кодом?",
      "answer": "Platform Channels - механизм Flutter для взаимодействия с нативным кодом (Java/Kotlin для Android, Objective-C/Swift для iOS).\n\nТипы Platform Channels:\n1. MethodChannel: вызов методов (двусторонняя коммуникация)\n2. EventChannel: потоковые события (от натива к Flutter)\n3. BasicMessageChannel: простые сообщения (реже используется)\n\nАрхитектура:\nFlutter (Dart) ↔ Platform Channel ↔ Native (Java/Kotlin/Swift/Obj-C)\n\nПример MethodChannel:\n\n// Dart сторона\nclass NativeBridge {\n  static const platform = MethodChannel('com.example/app');\n\n  static Future<String> getPlatformVersion() async {\n    try {\n      final version = await platform.invokeMethod('getPlatformVersion');\n      return version;\n    } catch (e) {\n      return 'Failed to get version: \$e';\n    }\n  }\n\n  static Future<void> showNativeDialog(String title, String message) async {\n    try {\n      await platform.invokeMethod('showDialog', {\n        'title': title,\n        'message': message,\n      });\n    } catch (e) {\n      print('Error: \$e');\n    }\n  }\n}\n\n// Android сторона (Kotlin)\nclass MainActivity : FlutterActivity() {\n  override fun configureFlutterEngine(flutterEngine: FlutterEngine) {\n    super.configureFlutterEngine(flutterEngine)\n    \n    MethodChannel(flutterEngine.dartExecutor.binaryMessenger, \"com.example/app\")\n        .setMethodCallHandler { call, result ->\n            when (call.method) {\n                \"getPlatformVersion\" -> {\n                    result.success(\"Android \${android.os.Build.VERSION.RELEASE}\")\n                }\n                \"showDialog\" -> {\n                    val title = call.argument<String>(\"title\")\n                    val message = call.argument<String>(\"message\")\n                    // Показать нативный диалог\n                    result.success(null)\n                }\n                else -> result.notImplemented()\n            }\n        }\n  }\n}\n\n// iOS сторона (Swift)\n@UIApplicationMain\n@objc class AppDelegate: FlutterAppDelegate {\n  override func application(\n    _ application: UIApplication,\n    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?\n  ) -> Bool {\n    let controller : FlutterViewController = window?.rootViewController as! FlutterViewController\n    \n    let channel = FlutterMethodChannel(name: \"com.example/app\",\n                                      binaryMessenger: controller.binaryMessenger)\n    channel.setMethodCallHandler({\n      (call: FlutterMethodCall, result: @escaping FlutterResult) -> Void in\n      switch call.method {\n      case \"getPlatformVersion\":\n        result(\"iOS \${UIDevice.current.systemVersion}\")\n      case \"showDialog\":\n        let args = call.arguments as! [String: Any]\n        let title = args[\"title\"] as! String\n        let message = args[\"message\"] as! String\n        // Показать нативный диалог\n        result(nil)\n      default:\n        result(FlutterMethodNotImplemented)\n      }\n    })\n    \n    return super.application(application, didFinishLaunchingWithOptions: launchOptions)\n  }\n}\n\nПример EventChannel (получение событий батареи):\n\n// Dart сторона\nclass BatteryChannel {\n  static const eventChannel = EventChannel('com.example/battery');\n\n  Stream<int> get batteryLevel {\n    return eventChannel.receiveBroadcastStream().map((level) => level as int);\n  }\n}\n\n// Использование\nStreamBuilder<int>(\n  stream: BatteryChannel().batteryLevel,\n  builder: (context, snapshot) {\n    if (snapshot.hasData) {\n      return Text('Battery: \${snapshot.data}%');\n    }\n    return CircularProgressIndicator();\n  },\n)\n\nЛучшие практики:\n1. Минимизируйте вызовы через channel (они дорогие)\n2. Используйте простые типы данных (String, int, bool, List, Map)\n3. Обрабатывайте ошибки на обеих сторонах\n4. Документируйте все методы\n5. Тестируйте на обеих платформах\n\nПакеты для упрощения работы:\n- pigeon (генерация кода для channels)\n- flutter_platform_channels\n\nОграничения:\n- Асинхронная коммуникация\n- Нет поддержки сложных объектов\n- Производительность хуже, чем чистый Dart\n\nКогда использовать Platform Channels:\n1. Доступ к нативным API\n2. Использование существующих нативных библиотек\n3. Критичные по производительности операции\n4. Специфичные для платформы фичи\n\nКогда НЕ использовать:\n1. Если есть Flutter-альтернатива\n2. Для простых операций\n3. Когда важна кроссплатформенная一致性",
      "hint": "MethodChannel для вызовов, EventChannel для событий, минимизируйте вызовы, используйте pigeon"
    },
    {
      "id": "30",
      "category": "CI/CD",
      "question": "Как настроить CI/CD для Flutter приложения?",
      "answer": "Настройка CI/CD (Continuous Integration/Continuous Deployment) критически важна для профессиональной разработки.\n\nОсновные этапы CI/CD пайплайна:\n1. Сборка (Build)\n2. Тестирование (Test)\n3. Анализ кода (Code Analysis)\n4. Сборка артефактов (Artifacts)\n5. Развертывание (Deployment)\n\nПопулярные CI/CD системы:\n1. GitHub Actions\n2. GitLab CI/CD\n3. Bitrise (специализированный для мобильных)\n4. Codemagic (специализированный для Flutter)\n5. Jenkins\n\nПример GitHub Actions workflow для Flutter:\n\n# .github/workflows/flutter.yml\nname: Flutter CI/CD\n\non:\n  push:\n    branches: [ main, develop ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    \n    steps:\n    - uses: actions/checkout@v2\n    \n    - name: Setup Flutter\n      uses: subosito/flutter-action@v2\n      with:\n        flutter-version: '3.0.0'\n        channel: 'stable'\n    \n    - name: Install dependencies\n      run: flutter pub get\n    \n    - name: Analyze code\n      run: flutter analyze\n    \n    - name: Run tests\n      run: flutter test --coverage\n    \n    - name: Upload coverage\n      uses: codecov/codecov-action@v2\n      with:\n        file: ./coverage/lcov.info\n\n  build-android:\n    needs: test\n    runs-on: ubuntu-latest\n    if: github.ref == 'refs/heads/main'\n    \n    steps:\n    - uses: actions/checkout@v2\n    \n    - name: Setup Flutter\n      uses: subosito/flutter-action@v2\n    \n    - name: Install dependencies\n      run: flutter pub get\n    \n    - name: Build APK\n      run: flutter build apk --release --split-per-abi\n    \n    - name: Build App Bundle\n      run: flutter build appbundle --release\n    \n    - name: Upload artifacts\n      uses: actions/upload-artifact@v2\n      with:\n        name: android-builds\n        path: build/app/outputs/\n\n  build-ios:\n    needs: test\n    runs-on: macos-latest\n    if: github.ref == 'refs/heads/main'\n    \n    steps:\n    - uses: actions/checkout@v2\n    \n    - name: Setup Flutter\n      uses: subosito/flutter-action@v2\n    \n    - name: Install dependencies\n      run: flutter pub get\n    \n    - name: Build iOS\n      run: flutter build ios --release --no-codesign\n    \n    - name: Upload artifacts\n      uses: actions/upload-artifact@v2\n      with:\n        name: ios-build\n        path: build/ios/\n\nКлючевые этапы пайплайна:\n\n1. Code Quality:\n   - flutter analyze (статический анализ)\n   - dart format --set-exit-if-changed (проверка форматирования)\n   - dart fix --apply (автоматическое исправление)\n\n2. Testing:\n   - flutter test --coverage (unit и widget тесты)\n   - flutter test integration_test (интеграционные тесты)\n   - flutter drive (UI тесты на эмуляторе)\n\n3. Building:\n   Для Android:\n   - flutter build apk --release\n   - flutter build appbundle --release (для Google Play)\n   - flutter build apk --split-per-abi (раздельные APK)\n   \n   Для iOS:\n   - flutter build ios --release\n   - flutter build ipa (для App Store)\n\n4. Code Signing:\n   Android:\n   - Создание keystore\n   - Настройка signingConfig в build.gradle\n   \n   iOS:\n   - Сертификаты и профили в Apple Developer\n   - Fastlane match для управления сертификатами\n\n5. Deployment:\n   Android (Google Play):\n   - Использование fastlane supply\n   - Или Google Play Console API\n   \n   iOS (App Store/TestFlight):\n   - fastlane pilot (TestFlight)\n   - fastlane deliver (App Store)\n   \n   Firebase App Distribution:\n   - Для бета-тестирования\n   - Поддержка Android и iOS\n\n6. Fastlane (автоматизация):\n   # Fastfile\n   lane :beta do\n     increment_build_number(\n       build_number: latest_testflight_build_number + 1\n     )\n     build_app(\n       workspace: \"Runner.xcworkspace\",\n       scheme: \"Runner\"\n     )\n     upload_to_testflight\n   end\n\n7. Environment Management:\n   - Использование .env файлов\n   - Пакет flutter_dotenv\n   - Разные конфигурации для dev/stage/prod\n\n8. Monitoring and Analytics:\n   - Sentry для отслеживания ошибок\n   - Firebase Analytics\n   - Firebase Performance Monitoring\n\nЛучшие практики:\n1. Храните секреты в secrets CI/CD системы\n2. Кэшируйте зависимости (pub cache)\n3. Используйте матрицы для тестирования на разных версиях\n4. Настройте автоматическое увеличение версий\n5. Добавьте уведомления (Slack, Email)\n6. Регулярно обновляйте Flutter версию\n\nСпециализированные сервисы для Flutter:\n1. Codemagic: готовые workflows для Flutter\n2. Bitrise: шаблоны для мобильной разработки\n3. Nevercode: автоматизация сборок\n\nПример настройки переменных окружения:\n# В GitHub Secrets\nGOOGLE_SERVICES_JSON: содержание google-services.json\nKEYSTORE_PASSWORD: пароль от keystore\n\n# В workflow\n- name: Setup Google Services\n  run: echo \"\${{ secrets.GOOGLE_SERVICES_JSON }}\" > android/app/google-services.json",
      "hint": "GitHub Actions/Fastlane, тестирование перед сборкой, автоматическое увеличение версий, кэширование зависимостей"
    }
  ]
}